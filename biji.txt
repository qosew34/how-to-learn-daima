
string某项是char
0.00是-0.00
考虑0的情况

快速幂
int qpow(int a, int n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a;
    else
    {
        int temp = qpow(a, n / 2);
        return temp * temp;
    }
}

    a.assign(R, vector<int>(C));声明二维数组
vector.swap(vectorb)交换
奇葩输入：1957
二分需要+-1便于修正
倒序搜索：1003
1928 栈与pair
堆 1090

(条件?条件成立：条件不成立)
vector<vector<pair<int, int>>>存整数对的二维数组
pow(x,a)==a^x
floor,ceil
sort用法：sort(tp,tp+3);/*tp指向第一个元素，tp+n(n为元素个数)指向最后一个元素之后的位置*/(tp是数组名字)
大数计算：1009 #include <gmp.h> apt install libgmp-dev（或者用python）

int ascii = static_cast<int>(ch); ascii=65
char ch =static_cast<char>(65); ch=a

a是97 z是122 A65 Z90
\1指的是ascii中的1

//字典序会自动对此，不存在的补0，a>0
实数是double不是int
vector名字.pop_back 回溯
我感觉还得理解一下：1219
pow(2,n):2^n
位运算
| 运算符  | 名称       | 例子     | 结果（二进制）              | 结果（十进制）         |   |
| ---- | -------- | ------ | -------------------- | --------------- | - |
| `&`  | 按位与 AND  | 5 & 3  | 101 & 011 → 001      | 1               |   |
| `    | `        | 按位或 OR | 5 | 3                | 101 | 011 → 111 | 7 |
| `^`  | 按位异或 XOR | 5 ^ 3  | 101 ^ 011 → 110      | 6               |   |
| `~`  | 按位取反 NOT | ~5     | ~00000101 → 11111010 | -6 (补码)         |   |
| `<<` | 左移       | 5 << 1 | 101 → 1010           | 10              |   |
| `>>` | 右移       | 5 >> 1 | 101 → 10             | 2               |   |

埃氏筛
vector<int> generatePrimes(int limit) {
    vector<bool> isPrime(limit + 1, true);
    isPrime[0] = isPrime[1] = false;  // 0 和 1 不是素数
    for (int i = 2; i * i <= limit; ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j <= limit; j += i) {
                isPrime[j] = false;
            }
        }
    }
    vector<int> primes;
    for (int i = 2; i <= limit; ++i) {  // 从 2 开始
        if (isPrime[i]) primes.push_back(i);
    }
    return primes;
}

lambda表达式
[捕获列表](参数列表) -> 返回值类型 {函数体} 
auto cmp = [](const pii& a, const pii& b) {
if(a.first == b.first) return a.second > b.second; //值小优先
return a.first > b.first; //次数小优先
     };

注意事项：xy分清楚，不能写反
变量名字不能输错
if内==
冒泡排序
string某项是char
善用数论，同余.
初始化初始化初始化
void无返回值，有return写int或者double
有条件用longlong!!!
0.00是-0.00
考虑0的情况
奇葩输入：1957
递归：1010
二分：1024
倒序搜索：1003
1928 栈与pair
getline：读真全部一行，无视换行符
cin>> ：读到第一个空格
(条件?条件成立：条件不成立)
vector<vector<pair<int, int>>>存整数对的二维数组
pow(x,a)==a^x
floor,ceil
sort用法：sort(tp,tp+3);/*tp指向第一个元素，tp+n(n为元素个数)指向最后一个元素之后的位置*/(tp是数组名字)
大数计算：1009 #include <gmp.h> apt install libgmp-dev（或者用python）
!!! -'0' ascii变数字
int ascii = static_cast<int>(ch); ascii=65
char ch =static_cast<char>(65); ch=a
a是97 z是122 A65 Z90
\1指的是ascii中的1
最好有初始化数值
//字典序会自动对此，不存在的补0，a>0
实数是double不是int
push_back(to_string (a))把a转成string再塞进去
<=

pow(2,n):2^n
位运算
| 运算符  | 名称       | 例子     | 结果（二进制）              | 结果（十进制）         |   |
| ---- | -------- | ------ | -------------------- | --------------- | - |
| `&`  | 按位与 AND  | 5 & 3  | 101 & 011 → 001      | 1               |   |
| `    | `        | 按位或 OR | 5 | 3                | 101 | 011 → 111 | 7 |
| `^`  | 按位异或 XOR | 5 ^ 3  | 101 ^ 011 → 110      | 6               |   |
| `~`  | 按位取反 NOT | ~5     | ~00000101 → 11111010 | -6 (补码)         |   |
| `<<` | 左移       | 5 << 1 | 101 → 1010           | 10              |   |
| `>>` | 右移       | 5 >> 1 | 101 → 10             | 2               |   |

埃氏筛
vector<int> generatePrimes(int limit) {
    vector<bool> isPrime(limit + 1, true);
    isPrime[0] = isPrime[1] = false;  // 0 和 1 不是素数
    for (int i = 2; i * i <= limit; ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j <= limit; j += i) {
                isPrime[j] = false;
            }
        }
    }
    vector<int> primes;
    for (int i = 2; i <= limit; ++i) {  // 从 2 开始
        if (isPrime[i]) primes.push_back(i);
    }
    return primes;
}